# (不)可变变量绑定

本节简单介绍一下RUST中的变量绑定(也叫声明，之所以叫绑定，是因为...往后看吧)


### let绑定变量 

直接上代码把： 

```
fn main() {
	// 标准的变脸声明: let variable: type = value;
	let a: i32 = 1;
}
```

### 可变变量 
在C/C++/Python语言中，我们应该没有见过这种约束，声明的变量不可以修改，我相信对于第一次接触这个概念的你
一定很迷茫，请习惯它；

RUST变量原则之一： 变量默认声明都是不可变的，要求编写代码的人必须明确的指出该变量是可变的才可以修改，

这样做的原因是:任何变量都代表一块内存(stack/heap)，这个内存默认权限是可读的，RUST为了保证内存安全，会在
编译阶段对内存访问进行大量检查，而把内存默认声明为不可变，可以大大减少编译器的工作量  


```
fn main() {
	// 标准的变脸声明: let variable: type = value;
	let a: i32 = 1;
	// 尝试修复它
	a = 2;
}
```

### 变量屏蔽

作为一名C语言开发者，你是否遇到过一段代码没有合适的变量给你用了？我经常遇到

RUST 的变量屏蔽功能一方面是为了解决其他语言的约束，另一方面是RUST语言自身的开发习惯需要这种能力


```
fn main() {
	let a: i32 = 1;
	// 原先的变量a此时已经被屏蔽掉(丢弃)，现在的变量a是新的变量
	// 变量屏蔽可以重新定义变量的可变性
	let mut a = a;
	
	// 也可以改变变量类型
	let a: u32 = 10;
}
```

### 未初始化变量

RUST变量原则之一： 不可以使用未初始化的变量，如果未使用，则不会破环这个规则

在C语言里面，本身是没有这个约束的，但是其实现在的编译器通过增加 *-Wuninitialized* 也可以实现这个检查 

RUST语言把这个规则作为默认规则，访问未初始化的内存，无论怎么看，都是危险的


```
fn main() {	
	// 修复它
	let a: i32;
	let b = a;
}
```

### 未使用变量

RUST变量建议之一： 未使用变量，会造成编译告警 

关于建议和原则: 这是我自己定义的名词，建议不会造成RUST 检查编译出错，但是会产生编译告警；如果原则被破环，
则会产生编译报错 

```
/// 使用注解 会告诉编译器 可以声明未使用变量
#[allow(unused_variables)] 
fn main() {	
	/// 使用下划线声明未变量，不会造成编译告警
	let _a: i32 = 10;
}
```


### 变量解构

支持多个变量的解构，该特性可以提高开发效率 写出更加简洁的代码

```
fn main() {
	// 利用元组实现一次声明和初始化多个变量 
	// 如果是C要实现相同功能 应该怎么做
	let (x,y,z) =  (1 ,2 ,3);
	println!("{} {} {}",x,y,z);
}
```

支持先定义变量元组，再进行解构 
```
fn main() {
    let (x, y);
	// 允许部分解构
    (x,..) = (3, 4);
    [.., y] = [1, 2];
    // Fill the blank to make the code work
    assert_eq!([x,y], [3,2]);

	// 从这里可以得知，变量也可以作为元组声明
    let (x, y): (i32,i32);
	(x,..) = (3, 4);
    assert_eq!(x, 3);
    println!("Success!");
} 
```